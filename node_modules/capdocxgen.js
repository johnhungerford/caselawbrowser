var xmldom = require('xmldom-qsa');
var docx = require('docx');


var err = function(msg) {
	console.log('Error!: ' + msg);
	return false;
}

var i = 0;

var findNodeByName = function(nodeIn, nodeNameIn) {

	console.log('findNodeByName(): Finding next node named: ' + nodeNameIn);

	while( nodeIn.nodeName != nodeNameIn ) {
		
		if( !(nodeIn = getNextNode(nodeIn)) ) {
			return err('findNodeByName(): unable to find node named ' + nodeNameIn + '! (getNextNode threw err.)');
		}

	}

	console.log('findNodeByName(): Footnote node found!: ' + nodeIn.nodeName);

	return nodeIn;
}

var getNextNode = function(nodeIn, endTag) {

	if(nodeIn.childNodes) { 

		return nodeIn.childNodes[0]; 

	} else if(nodeIn.nextSibling) {

		return nodeIn.nextSibling;

	} else {

		do {

			if ( nodeIn.parentNode ) {
				nodeIn = nodeIn.parentNode;
			} else {
				return err('getNextNode(): no more nodes!');
			}

			if ( nodeIn.nextSibling ) {
				if( nodeIn.nextSibling.nodeName == endTag ) {
					return err('getNextNode(): reached the limiting tag: ' + nodeIn.nextSibling.nodeName);
				}
				return nodeIn.nextSibling;
			} else {
				continue;
			}

		} while ( true );

	}

	return err('getNextNode(): somehow got out of search loop...');

}

var mapNode = function ( nodeIn, nodeHandler, datain ) { 

	var nodeIterator = nodeIn;
	var depth = 0;
	var skipnode = false;
	var i = 0;

	if ( !datain ) { 
		var data = { continue: true };
	} else {
		var data = datain;
		datain.continue = true;
	}

	data.maxdepth = 0;

	// Main explorer loop. Its task is to handle the current node (whether this means
	// outputting some information about it or building a document with it) and to
	// find the next node. It will continue until all nodes are handled.
	do {
		var exit = false;

		i++;
		console.log('mapNode(): Iteration: ' + i + '; Node: ' + nodeIterator.nodeName);

		if ( data.maxdepth < depth ) data.maxdepth = depth;

		// Skip over all footnote nodes
		if( nodeIterator.nodeName != 'footnote' ) {

			console.log('mapNode(): Not a footnote...');

			data = nodeHandler( nodeIterator, data, depth );

			console.log('mapNode(): Node handled...');

			if ( !data.continue ) { return err('mapNode(): nodeHandler fcn error!'); }

			// Now that we've handled the node, let's go on to the node's first child.
			// If we can do that, continue on to the beginning of the main loop to handle
			// that child. Otherwise, we'll proceed below to try to go on to the next
			// sibling.
			if( nodeIterator.childNodes) {
				console.log('mapNode(): Descending to childNodes[0]...');
				nodeIterator = nodeIterator.childNodes[0];
				depth++;
				continue;
			} 

		}

		// If the above was skipped (because we're in a footnote node) OR if there
		// are not childnodes to go to, we'll want to move on to the next sibling.
		// If we are able to do that, we can just continue on to the next iteration.
		if ( nodeIterator.nextSibling ) {
			console.log('mapNode(): Going on to nextSibling...');
			nodeIterator = nodeIterator.nextSibling;
			continue;
		}

		console.log('mapNode(): climbing back up...');
		// If you can't go down to the next child, or over to the next sibling, find
		// your way back up to the next available ancestor sibling
		do {

			// Go up to the parent unless we are at a depth of zero, this means we are 
			// at the end! (Note that we test depth and not the existence of a parent
			// so that we can use this function to explore subsections of a DOM object.)
			// If we are done, break the loop and exit(=true) the main loop.
			if ( depth != 0 ) {
				console.log('mapNode(): going up to parentNode...');
				nodeIterator = nodeIterator.parentNode;
				depth--;
			} else {
				console.log('mapNode(): no parentNode to climb to. Finished!');
				exit = true;
				break;
			}

			// Once we go up, go to the next sibling. If there's one to go to, we can
			// break out of this loop and continue (exit = false) the main loop. No 
			// sibling means we have to go up to the next parent again (which means 
			// continue this loop). 
			if ( nodeIterator.nextSibling ) {
				console.log('mapNode(): Found the next unexplored sibling!');
				nodeIterator = nodeIterator.nextSibling;
				break;
			} else {
				continue;
			}

		} while ( true );

	} while ( !exit );

	data.maxdepth = depth;

	return data;

}

var basicNodeReport = function( nodeIn, depth ) {

	var ittype = '';
	switch ( nodeIn.nodeType ) {
		case 1:
			ittype = 'Element';
			break;
		case 2:
			ittype = 'Attribute';
			break;
		case 3:
			ittype = 'Text';
			break;
		default:
			ittype = nodeIn.nodeType;
	}

	console.log( 'Depth: ' + depth );
	console.log( 'Node name: ' + nodeIn.nodeName + '; Node Type: ' + ittype);

}


var addLastParagraph = function( data ) {
	console.log('addLastParagraph(): Adding paragraph...');
	if ( data.Paragraph == undefined || data.Paragraph == null || data.doc == undefined ) { err('addLastParagraph(): no paragraph to add!'); }
	
	data.doc.addParagraph(data.Paragraph);

	data.Paragraph = null;

	console.log('addLastParagraph(): Added paragraph...');

	return true;
}

var startNewParagraph = function (data) {

	console.log('startNewParagraph(): Starting new paragraph...');
	
	addLastParagraph(data);

	data.Paragraph = new docx.Paragraph();

	if ( data.au ) {

		data.au = false;

		if ( !data.fn && !data.bq ) {
			console.log('startNewParagraph(): formatting author name');
			data.Paragraph.heading1(); /*.style('FnBqStyle');*/
		} else if ( !data.fn && data.bq ) {
			data.Paragraph.style('AuBqStyle'); /*.style('Normal'); AuBqStyle*/
		} else if ( data.fn && !data.bq ) {
			data.Paragraph.style('FnStyle') /*.style('Normal'); /*FnStyle*/
		} else if ( data.fn && data.bq) {
			data.Paragraph.style('NmBqStyle') /*.style('NmBqStyle');*/
		}

	} else if ( !data.au ) {
	
		if ( !data.fn && !data.bq ) {
			console.log('startNewParagraph(): formatting normal');
			data.Paragraph.style('NmStyle');
		} else if ( !data.fn && data.bq ) {
			console.log('startNewParagraph(): formatting blockquote');
			data.Paragraph.style('NmBqStyle');
		} else if ( data.fn && !data.bq ) {
			console.log('startNewParagraph(): formatting footnote');
			data.Paragraph.style('FnStyle'); 
		} else if ( data.fn && !data.bq ) {		} else if ( data.fn && data.bq) {
			console.log('startNewParagraph(): formatting footnote blockquote');
			data.Paragraph.style('FnBqStyle');
		}

	}

	if ( data.tpm ) {
		console.log('startNewParagraph(): formatting centered');
		data.Paragraph.style('topmatter');
	}

	console.log('startNewParagraph(): Started new paragraph...');

	return true;
}

var findFnNode = function (nodeIn, fnLabel) {

	while( nodeIn.nodeName != 'footnote' || nodeIn.attributes == undefined || nodeIn.attributes[0].value != fnLabel ) {
		console.log('findFnNode(): Finding footnote node: ' + fnLabel);
		if(nodeIn.nodeName == 'footnote') {
			if(nodeIn.attributes) {
				console.log('findFnNode(): footnote node\'s attributes[0]: '+ nodeIn.attributes[0].value );
			}
		}
		if( !(nodeIn = getNextNode(nodeIn, 'option')) ) {
			return err('findFnNode(): unable to find footnote node! (getNextNode threw err.)');
		}
	}

	console.log('findFnNode(): Footnote node found!: ' + nodeIn.attributes[0].value);

	return nodeIn;

}

var createFootnote = function( nodeIn, data ) {

	console.log('createFootnote(): Creating footnote...');

	if ( !nodeIn || !data ) { return err('createFootnote(): Either no nodeIn input or no data input'); }
	
	if ( !data.Paragraph ) { startNewParagraph(data); }

	data.Paragraph.addRun(new docx.TextRun('<FOOTNOTE>'));
	addLastParagraph(data);

	var fnNode;

	if( !(fnNode = findFnNode(nodeIn, nodeIn.textContent)) ) { return err('createFootnote(): Unable to find footnote node. (getNextNode() threw err.)'); }

	var newdata = {
		doc: data.doc,
		fn: true,
		bq: false,
		au: false,
		fnm: false,
	}

	if( fnNode.childNodes ) {
		newdata = mapNode( fnNode.childNodes[0], opinionHandler, newdata );
	}

	addLastParagraph(newdata);

	data.fnm = false;
	startNewParagraph(data);
	data.Paragraph.addRun(new docx.TextRun('</FOOTNOTE>'));

	return true;

}

var opinionHandler = function( nodeIn, data, depth ) {

	i++;

	if ( !nodeIn || !data || !data.doc || depth == undefined ) { 
		console.log(nodeIn.nodeName + ' ' + data.continue + ' ' + depth );
		data.continue = false;
		return data;
	}

	console.log('opinionHandler(): handling node: ' + nodeIn.nodeName);


	if (nodeIn.nodeName == 'casebody' ) {
		data.bdyct = 0;
	} else if ( nodeIn.nodeName == 'opinion' ) {
		data.bdyct++;
		data.tpm = false;
		data.au = false;
		data.fn = false;
		data.fnm = false;
		data.bq = false;
		data.skip = false;
		addLastParagraph(data);
	} else if ( nodeIn.nodeName == 'docketnumber' || nodeIn.nodeName == 'parties' || nodeIn.nodeName == 'lastpage' || nodeIn.nodeName == 'firstpage') {
		data.skip = true;
	} else if ( nodeIn.nodeName == 'judges' || nodeIn.nodeName == 'attorneys' ) {
		data.bdyct++ ;
		console.log('Incremented data.bdyct: ' + data.bdyct);
		data.tpm = false;
		data.au = false;
		data.fn = false;
		data.fnm = false;
		data.bq = false;
		data.skip = false;
		startNewParagraph(data);
	} else if ( nodeIn.nodeName == 'decisiondate' || nodeIn.nodeName == 'otherdate' ) {
		data.tpm = true;
		data.au = false;
		data.fn = false;
		data.fnm = false;
		data.bq = false;
		console.log('DECISIONDATE');
		startNewParagraph(data);
		data.tpm = false;
		data.skip = false;
	} else if ( nodeIn.nodeName == 'author') {
		console.log('opinionHandler(): author node...');
		data.bdyct++;
		data.au = true;
		data.tpm = false;
		data.fn = false;
		data.fnm = false;
		data.bq = false;
		data.skip = false;
		startNewParagraph(data);
	} else if ( nodeIn.nodeName == 'p') {
		data.fnm = false;
		data.au = false;
		data.bq = false;
		console.log('opinionHandler(): paragraph node...')
		startNewParagraph(data);
	} else if  ( nodeIn.nodeName == 'blockquote') {
		console.log('opinionHandler(): blockquote node...')
		data.bq = true;
		data.tpm = false;
		startNewParagraph(data);
	} else if ( nodeIn.nodeName == 'footnotemark' ) {
		console.log('opinionHandler(): footnotemark node...');
		data.fnm = true;
	} else if ( nodeIn.nodeName == '#text' ) {
		console.log('opinionHandler(): text node...');

		if ( data.skip ) { return data; }

		if ( nodeIn.textContent == ' ' ) { return data; }

		if ( data.fnm ) {
			console.log('opinionHandler(): creating footnote: ' + nodeIn.textContent);
			createFootnote( nodeIn, data );
			data.fnm = false;
			return data;
		}

		if ( !data.Paragraph ) { startNewParagraph(data); }
		
		console.log('opinionHandler(): adding text to paragraph: ' + nodeIn.textContent);
		data.Paragraph.addRun( new docx.TextRun(nodeIn.textContent) );
		
	}

	if( data.bdyct == 1 ) {
		console.log('ADDING EXTRA PARAGRAPH BETWEEN TOPMATTER AND BODY');
		data.doc.addParagraph(new docx.Paragraph());
		data.bdyct++;
	}

	console.log('Body Count: ' + data.bdyct);

	return data;

}

var styleCaseDocx = function(doc) {

	doc.Styles.createParagraphStyle('title', 'Title')
		.size(40)
		.font('Times New Roman')
		.bold()
		.color('000000')
		.center()
		.spacing({before: 0, after: 480, line: 240});

	doc.Styles.createParagraphStyle('topmatter', 'Top Matter')
		.size(24)
		.font('Times New Roman')
		.color('000000')
		.bold()
		.center()
		.spacing({before: 0, after: 239, line: 240});

	doc.Styles.createParagraphStyle('Heading1', 'Heading 1')
		.size(28)
		.font('Times New Roman')
		.bold()
		.color('000000')
		.spacing({before: 478, after: 239, line: 240});

	doc.Styles.createParagraphStyle('Heading2', 'Heading 2')
		.size(24)
		.font('Times New Roman')
		.bold()
		.color('000000')
		.spacing({before: 478, after: 239, line: 240});

	doc.Styles.createParagraphStyle('NmStyle', 'Normal')
		.size(24)
		.font('Times New Roman')
		.color('000000')
		.spacing({before: 0, after: 239, line: 240});

	doc.Styles.createParagraphStyle('NmBqStyle', 'Block Quote')
		.size(24)
		.font('Times New Roman')
		.color('000000')
		.indent({ left: 720 })
		.spacing({before: 0, after: 239, line: 240});

	doc.Styles.createParagraphStyle('FnStyle', 'Footnote')
		.size(20)
		.font('Time New Roman')
		.color('000000')
		.spacing({before: 0, after: 120, line: 240});

	doc.Styles.createParagraphStyle('FnBqStyle', 'Footnote Blockquote')
		.size(20)
		.font('Time New Roman')
		.color('000000')
		.indent({ left: 720 })
		.spacing({before: 0, after: 120, line: 240});

	doc.Styles.createParagraphStyle('AuBqStyle')
		.size(32)
		.font('Times New Roman')
		.color('000000')
		.spacing({before: 0, after: 239, line: 240});

	return doc;

}

var buildTopMatter = function(doct, JsnObj) {

	if(JsnObj.name_abbreviation) { 
		doct.addParagraph(new docx.Paragraph(JsnObj.name_abbreviation).style('title'));
	}
	if(JsnObj.court) {
		if(JsnObj.court.name) {
			doct.addParagraph(new docx.Paragraph(JsnObj.court.name).style('topmatter'));
		}
	}
	if(JsnObj.citations) {
		for(var i = 0; i < JsnObj.citations.length; i++) {
			doct.addParagraph(new docx.Paragraph(JsnObj.citations[i].cite).style('topmatter'));
		}
	}
	if(JsnObj.docket_number) {
		doct.addParagraph(new docx.Paragraph(JsnObj.docket_number).style('topmatter'));
	}
	if(JsnObj.name) {
		doct.addParagraph(new docx.Paragraph(JsnObj.name).style('topmatter'));
	}

	return doct;
	
}

var buildCaseDocx = function (caseJsonObj) {

	var doct = new docx.Document();

	if ( !(doct = styleCaseDocx(doct)) ) { return err('buildCaseDocx(): styling the docx doc didn\' work!'); }

	if ( !(doct = buildTopMatter(doct, caseJsonObj)) ) { return err('buildCaseDocx(): failed to add top matter'); }

	var caseDom = {};

	if (caseJsonObj && caseJsonObj.casebody && caseJsonObj.casebody.data) {
		caseDom = new xmldom.DOMParser().parseFromString(caseJsonObj.casebody.data);
	} else {
		return err('buildDocx(): no xml string!');
	}

	caseDom = findNodeByName(caseDom, 'casebody');

	if ( !caseDom ) { return err('buildDocx(): unable to find "casebody" node!'); }

	var data = mapNode(caseDom, opinionHandler, { doc: doct });
	addLastParagraph(data);


	return data.doc;

}

module.exports.mapNode = mapNode;
module.exports.getNextNode = getNextNode;
module.exports.opinionHandler = opinionHandler;
module.exports.basicNodeReport = basicNodeReport;
module.exports.createFootnote = createFootnote;
module.exports.findFnNode = findFnNode;
module.exports.addLastParagraph = addLastParagraph;
module.exports.startNewParagraph = startNewParagraph;
module.exports.buildTopMatter = buildTopMatter;
module.exports.buildCaseDocx = buildCaseDocx;
